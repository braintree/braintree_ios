import Foundation

/// An authorization string used to initialize the Braintree SDK
@objcMembers public class BTClientToken: NSObject, NSCoding, NSCopying {

    /// The client token as a BTJSON object
    public let json: BTJSON

    /// The extracted authorization fingerprint
    public let authorizationFingerprint: String

    /// The extracted configURL
    public let configURL: URL

    /// The original string used to initialize this instance
    public let originalValue: String

    /// Initialize a client token with a client token string generated by a Braintree Server Library.
    /// - Parameter clientToken: A client token string generated by a Braintree Server Library
    @objc(initWithClientToken:error:)
    public init(clientToken: String) throws {
        // Client token must be decoded first because the other values are retrieved from it
        self.json = try Self.decodeClientToken(clientToken)
        
        guard let authorizationFingerprint = json["authorizationFingerprint"].asString(),
              !authorizationFingerprint.isEmpty else {
            throw BTClientTokenError.invalidAuthorizationFingerprint
        }
        
        guard let configURL = json["configUrl"].asURL() else {
            throw BTClientTokenError.invalidConfigURL
        }
        
        self.authorizationFingerprint = authorizationFingerprint
        self.configURL = configURL
        self.originalValue = clientToken
    }
    
    // MARK: - Internal helper functions

    private static func decodeClientToken(_ rawClientToken: String) throws -> BTJSON {
        let data: Data
        let isBase64: Bool
        if let base64Data = Data(base64Encoded: rawClientToken) {
            data = base64Data
            isBase64 = true
        } else if let utf8Data = rawClientToken.data(using: .utf8) {
            data = utf8Data
            isBase64 = false
        } else {
            throw BTClientTokenError.invalidFormat
        }

        return try toBTJSON(data: data, isBase64: isBase64)
    }

    private static func toBTJSON(data: Data, isBase64: Bool) throws -> BTJSON {
        guard let clientTokenJSON = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw BTClientTokenError.invalidJSON
        }

        guard let version = clientTokenJSON["version"] as? Int else {
            throw BTClientTokenError.invalidFormat
        }

        // Version 1 must be utf8, versions 2 & 3 must be base64
        switch version {
        case 1:
            if isBase64 {
                throw BTClientTokenError.expectedUTF8Encoding
            }

        case 2, 3:
            if !isBase64 {
                throw BTClientTokenError.expectedBase64Encoding
            }
            
        default:
            throw BTClientTokenError.unsupportedVersion
        }

        return BTJSON(value: clientTokenJSON)
    }

    // MARK: - NSCoding conformance

    public func encode(with coder: NSCoder) {
        coder.encode(originalValue, forKey: "originalValue")
    }

    public required convenience init?(coder: NSCoder) {
        try? self.init(
            clientToken: coder.decodeObject(forKey: "originalValue") as? String ?? ""
        )
    }

    // MARK: - NSCopying conformance

    @objc(copyWithZone:)
    public func copy(with zone: NSZone? = nil) -> Any {
        do {
            return try BTClientToken(clientToken: self.originalValue)
        } catch {
            return error
        }
    }

    // MARK: - isEqual override

    public override func isEqual(_ object: Any?) -> Bool {
        guard object is BTClientToken,
              let otherToken = object as? BTClientToken else {
            return false
        }

        return self.json.asDictionary() == otherToken.json.asDictionary()
    }
}
